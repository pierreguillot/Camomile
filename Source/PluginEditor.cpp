/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

static inline juce::Colour tojColor(std::array<float, 4> const& color)
{
    return juce::Colour::fromFloatRGBA(color[0], color[1], color[2], color[3]);
}

static inline juce::Path tojPath(int size, t_pt* points)
{
    juce::Path path;
    for(int i = 0; i < size; i++)
    {
        if(points[i].x == E_PATH_MOVE && i < size - 1)
        {
            path.startNewSubPath(points[i+1].x, points[i+1].y);
            ++i;
        }
        else if(points[i].x == E_PATH_LINE && i < size - 1)
        {
            path.lineTo(points[i+1].x, points[i+1].y);
            ++i;
        }
        else if(points[i].x == E_PATH_CURVE && i < size - 3)
        {
            path.cubicTo(points[i+1].x, points[i+1].y,
                         points[i+2].x, points[i+2].y,
                         points[i+3].x, points[i+3].y);
            i += 3;
        }
        else if(points[i].x == E_PATH_CLOSE)
        {
            path.closeSubPath();
        }
    }
    
    return path;
}

Interface::Interface(sGui object) :
m_object(object),
m_messenger(make_shared<Messenger>(object->getBindingName()))
{
    if(object)
    {
        const std::array<int,2> bounds = object->getSize();
        Component::setSize(bounds[0], bounds[1]);
        Component::setVisible(true);
        Component::setInterceptsMouseClicks(object->wantMouse(), object->wantMouse());
        Component::setMouseClickGrabsKeyboardFocus(object->wantKeyboard());
        Component::setWantsKeyboardFocus(object->wantKeyboard());
    }
}

void Interface::paint(Graphics& g)
{
    sGui object = m_object.lock();
    if(object)
    {
        m_messenger->addListener(this);
        g.fillAll(tojColor(object->getBackgroundColor()));
        std::vector<t_elayer*> layers(object->paint());
        for(auto it : layers)
        {
            if(it->e_state == EGRAPHICS_TODRAW)
            {
                for(int j = 0; j < it->e_number_objects; j++)
                {
                    t_egobj const& obj = it->e_objects[j];
                    t_rgba col = hex_to_rgba(obj.e_color->s_name);
                    g.setColour(tojColor(std::array<float, 4>({col.red, col.green, col.blue, col.alpha})));
                    if(obj.e_type == E_GOBJ_PATH || obj.e_type == E_GOBJ_RECT)
                    {
                        juce::Path path(tojPath(obj.e_npoints, obj.e_points));
                        if(obj.e_filled)
                        {
                            g.fillPath(path);
                        }
                        else
                        {
                            g.strokePath(path, PathStrokeType(obj.e_width));
                        }
                    }
                    else if(obj.e_type == E_GOBJ_OVAL)
                    {
                        if(obj.e_filled)
                        {
                            g.fillEllipse(obj.e_points[0].x, obj.e_points[0].y,
                                          obj.e_points[1].x - obj.e_points[0].x,
                                          obj.e_points[1].y - obj.e_points[0].y);
                        }
                        else
                        {
                            g.drawEllipse(obj.e_points[0].x, obj.e_points[0].y,
                                          obj.e_points[1].x - obj.e_points[0].x,
                                          obj.e_points[1].y - obj.e_points[0].y,
                                          obj.e_width);
                        }
                    }
                    else if(obj.e_type == E_GOBJ_ARC)
                    {
                        Path path;
                        //path.addCentredArc(obj.e_points[0].x, obj.e_points[0].y, obj.e_points[1].x, obj.e_points[1].y,, )
                        /*
                         if(obj.e_filled)
                         {
                         g.fillRect(obj.e_points[0].x, obj.e_points[0].y, obj.e_points[1].x, obj.e_points[1].y);
                         }
                         else
                         {
                         g.drawRect(obj.e_points[0].x, obj.e_points[0].y, obj.e_points[1].x, obj.e_points[1].y);
                         }*/
                    }
                    else if(obj.e_type == E_GOBJ_TEXT)
                    {
                        /*
                        g.drawText(juce::String(obj.e_text->s_name),
                                   obj.e_points[0].x,
                                   obj.e_points[0].y,
                                   obj.e_points[1].x,
                                   obj.e_points[1].y,
                                   juce::Justification(juce::Justification::centred), true);
                         */
                        
                    }
                }
                it->e_state = EGRAPHICS_CLOSE;
            }
        }
        g.setColour(tojColor(object->getBorderColor()));
        g.drawRect(getBounds().withZeroOrigin(), object->getBorderSize());
    }
    else
    {
        g.fillAll(Colours::whitesmoke);
    }
}

void Interface::mouseMove(const MouseEvent& event)
{
    sGui object = m_object.lock();
    if(object)
    {
        object->mouseMove({float(event.x), float(event.y)}, event.mods.getRawFlags());
    }
}

void Interface::mouseEnter(const MouseEvent& event)
{
    sGui object = m_object.lock();
    if(object)
    {
        object->mouseEnter({float(event.x), float(event.y)}, event.mods.getRawFlags());
    }
}

void Interface::mouseExit(const MouseEvent& event)
{
    sGui object = m_object.lock();
    if(object)
    {
        object->mouseExit({float(event.x), float(event.y)}, event.mods.getRawFlags());
    }
}

void Interface::mouseDown(const MouseEvent& event)
{
    sGui object = m_object.lock();
    if(object)
    {
        object->mouseDown({float(event.x), float(event.y)}, event.mods.getRawFlags());
    }
}

void Interface::mouseDrag(const MouseEvent& event)
{
    sGui object = m_object.lock();
    if(object)
    {
        object->mouseDrag({float(event.x), float(event.y)}, event.mods.getRawFlags());
    }
}

void Interface::mouseUp(const MouseEvent& event)
{
    sGui object = m_object.lock();
    if(object)
    {
        object->mouseUp({float(event.x), float(event.y)}, event.mods.getRawFlags());
    }
}

void Interface::mouseDoubleClick(const MouseEvent& event)
{
    sGui object = m_object.lock();
    if(object)
    {
        object->mouseDoubleClick({float(event.x), float(event.y)}, event.mods.getRawFlags());
    }
}

void Interface::mouseWheelMove(const MouseEvent& event, const MouseWheelDetails& wheel)
{
    sGui object = m_object.lock();
    if(object)
    {
        object->mouseWheelMove({float(event.x), float(event.y)}, event.mods.getRawFlags(), {wheel.deltaX, wheel.deltaY});
    }
}

void Interface::receive(const std::string& dest, t_symbol* s)
{
    const MessageManagerLock thread(Thread::getCurrentThread());
    if(thread.lockWasGained())
    {
        repaint();
    }
}

CamomileAudioProcessorEditor::CamomileAudioProcessorEditor(CamomileAudioProcessor& p) :
AudioProcessorEditor(&p),
m_processor(p),
m_file_drop(false)
{
    m_processor.addListener(this);
    shared_ptr<const Patch> patch = m_processor.getPatch();
    if(patch)
    {
        sGui camo = patch->getCamomile();
        if(camo)
        {
            const std::vector<sObject> objects = patch->getObjects();
            const std::array<int,2> ref = camo->getPosition();
            for(auto it : objects)
            {
                if(it != camo && it->isGui())
                {
                    Interface* inte = m_objects.add(new Interface(dynamic_pointer_cast<Gui>(it)));
                    const std::array<int,2> pos = it->getPosition();
                    inte->setTopLeftPosition(pos[0] - ref[0], pos[1] - ref[1]);
                    addAndMakeVisible(inte);
                }
            }
        }
        
    }
    setSize(600, 400);
}

CamomileAudioProcessorEditor::~CamomileAudioProcessorEditor()
{
    m_processor.removeListener(this);
}

void CamomileAudioProcessorEditor::paint(Graphics& g)
{
    shared_ptr<const Patch> patch = m_processor.getPatch();
    if(patch)
    {
        sGui camo = patch->getCamomile();
        if(camo)
        {
            g.fillAll(tojColor(camo->getBackgroundColor()));
            g.setColour(tojColor(camo->getBorderColor()));
            g.drawRect(getBounds().withZeroOrigin());
        }
        else
        {
            g.fillAll(Colours::white);
            g.setColour(Colours::black);
            g.setFont (15.0f);
            g.drawText(juce::String("The patch is not valid !"), getBounds().withZeroOrigin(), juce::Justification::centred);
        }
    }
    else
    {
        g.fillAll(Colours::white);
        g.setColour(Colours::black);
        g.setFont (15.0f);
        g.drawText(juce::String("Drag & Drop your patch..."), getBounds().withZeroOrigin(), juce::Justification::centred);
    }
    
    if(m_file_drop)
    {
        g.fillAll(Colours::lightblue.withAlpha(0.2f));
    }
}

bool CamomileAudioProcessorEditor::isInterestedInFileDrag(const StringArray& files)
{
    if(files.size())
    {
        for(int i = 0; i < files.size(); i++)
        {
            if(files[i].endsWith(juce::StringRef(".pd")))
            {
                return true;
            }
        }
    }
    return false;
}

void CamomileAudioProcessorEditor::filesDropped(const StringArray& files, int x, int y)
{
    if(files.size())
    {
        for(int i = 0; i < files.size(); i++)
        {
            juce::File file(files[i]);
            if(file.getFileExtension() == juce::String(".pd"))
            {
                m_processor.loadPatch(file);
            }
        }
    }
}

void CamomileAudioProcessorEditor::patchChanged()
{
    removeAllChildren();
    m_objects.clear(true);
    shared_ptr<const Patch> patch = m_processor.getPatch();
    if(patch)
    {
        sGui camo = patch->getCamomile();
        if(camo)
        {
            const std::vector<sObject> objects = patch->getObjects();
            const std::array<int,2> ref = camo->getPosition();
            for(auto it : objects)
            {
                if(it != camo && it->isGui())
                {
                    Interface* inte = m_objects.add(new Interface(dynamic_pointer_cast<Gui>(it)));
                    const std::array<int,2> pos = it->getPosition();
                    inte->setTopLeftPosition(pos[0] - ref[0], pos[1] - ref[1]);
                    addAndMakeVisible(inte);
                }
            }
        }
        
    }
    const MessageManagerLock mmLock;
    if(mmLock.lockWasGained())
    {
        repaint();
    }
}

void CamomileAudioProcessorEditor::fileDragEnter(const StringArray& files, int x, int y)
{
    const MessageManagerLock mmLock;
    if(mmLock.lockWasGained())
    {
        m_file_drop = true;
        repaint();
    }
}

void CamomileAudioProcessorEditor::fileDragExit(const StringArray& files)
{
    m_file_drop = false;
    repaint();
}

void CamomileAudioProcessorEditor::resized()
{
    
}
